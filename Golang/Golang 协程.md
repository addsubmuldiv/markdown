

# Golang 协程

## 调度模型——三个级别

- 线程M
- 处理器P(非CPU，只是用来调度协程的一个程序)
- 协程G

### 协程队列

每个 **P** 有一个协程队列，此外还有一个全局队列；每个 P 就负责调度自己的队列中的 G，当自己的队列满了的时候，新添加的 G 会被放到全局队列里面。



## 调度策略

### 轮转

每个P就负责自己的G，干完了再去全局里面拿

### 系统调用

下图为 **一个协程阻塞时的调度方式**

![image-20210825183312568](E:\markdown\Golang\images\image-20210825183312568.png)



### 工作量窃取

如果有个 P 自己的活干完了，会去别的 P 那里偷 G 过来干

### 抢占式调度

每个 P 会监控 G 的运行时间，让他们按时间片轮转，Go 1.14 以前在遇到无函数调用死循环的时候，会导致不调度，之后引入了 基于信号 的抢占机制，解决了这个问题