# 第九章-一致性与共识

为了构建容错系统，最好先建立一套通用的抽象机制和与之对应的技术保证，这样只需实现一次，其上的各种应用程序都可以安全地信赖底层的保证。



==**事务与分布式一致性的对比**==

这与第7章我们引入事务的道理相同：通过事务、应用程序可以假装没有崩溃（原子性），没有与其他人并发访问数据库（隔离性）、且存储设备是完全可靠的（持久性）：总之，抽象的事务机制可以屏蔽系统内部很多复杂的问题，例如发生崩溃、边界条件、磁盘故障等，使得应用层轻松无忧。

事务隔离主要是为了处理并发执行事务时的各种临界条件，而分布式一致性则主要是针对延迟和故障等问题来协调副本之间的状态



## 线性一致性(可线性化)

在一个可线性化的系统中， 一旦某个客户端成功提交写请求 ，所有客户端的读请求一定都能看到刚刚写入的值。



可线性化并不意味着可串行化，

**可串行化**指的是事务的隔离级别，它用来确保事务执行的结果与串行执行（即每次执行一个事务）完全相同，即使串行执行的顺序和事务的实际执行顺序可能完全不同

**可线性化**指的是读写寄存器（单个对象）的最新值保证，它并不要求将操作组合到事务中。因此无法避免写偏斜问题（第7章）



数据库可以同时支持可串行化与线性化，这种组合又被称为严格的可串行化或者强的单副本可串行化( strong one- copy serializability, strong-SR)。基于**两阶段加锁**(参阅第7章“两阶段加锁”)或者**实际以串行执行**(参阅第7章“实际串行执行”)都是典型的可线性化。





### 哪些场景需要可线性化？

#### 加锁与主节点选举

在主从复制系统中选择主节点的时候，通常使用锁来实现，所有节点都尝试获取锁，只有一个可以得到，这个需要满足可线性化，即所有节点必须同意哪个节点持有锁，否则就会出问题。

ZooKeeper和etcd通常用来实现分布式锁和主节点选举，都采用了支持容错的==共识算法==**（Raft之类的）**来确保可线性化。

归根结底，线性化存储是所有这些协调服务的基础。



#### 约束和唯一性保证

这种情况本质上与加锁非常类似：用户注册等同于试图对用户名进行加锁操作。该操作也类似于原子比较和设置：如果当前用户名尚未被使用，就设置用户名与客户1D进行关联。

然而，硬性的唯一性约束，常见如关系型数据库中主键的约束，则需要线性化保证。其他如外键或属性约束，则并不要求一定线性化。



#### 跨通道时间依赖

==看不懂==

### 实现线性化系统

最简单的方法，只使用一个数据副本

几种复制方案对线性化的支持

- 主从复制（部分支持）：如果从主节点或者同步更新的从节点读取，那是可线性化的。但是如果采用了快照隔离，或者并发时出现bug就不行了。还有就是主节点出问题了
- 共识算法（可线性化）：共识协议通常内置一些措施来防止裂脑和过期的副本。正是由于这些专门的设计，共识算法可以安全地实现线性化存储，这些系统包括 ZooKeeper和etcd等。
- 多主复制（不可线性化）：多个节点并发写入
- 无主复制（可能不行）：取决于 quorum 的方法



### 可线性化的代价

![img](https://gitee.com/Lighters_c/picgo-bed/raw/master/fig9-7.png)

**网络中断迫使在线性一致性和可用性之间做出选择。**



### CAP定理

- 如果应用需要线性一致性，且某些副本因为网络问题与其他副本断开连接，那么这些副本掉线时不能处理请求。请求必须等到网络问题解决，或直接返回错误。（无论哪种方式，服务都**不可用（unavailable）**）。
- 如果应用不需要线性一致性，那么某个副本即使与其他副本断开连接，也可以独立处理请求（例如多主复制）。在这种情况下，应用可以在网络问题前保持可用，但其行为不是线性一致的。

不需要线性一致性的应用对网络问题有更强的容错能力。这种见解通常被称为**CAP定理**

CAP理论告诉我们：一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中两项。

==发生网络故障时，你必须在线性一致性和整体可用性之间做出选择。因此，CAP更好的表述成：在分区时要么选择一致，要么选择可用==



### **BASE理论**

BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：**即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性**。

**1、基本可用**

基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性----注意，这绝不等价于系统不可用。比如：

（1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒

（2）系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面

**2、软状态**

软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时

**3、最终一致性**

最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，**它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态**。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。



## 顺序保证

**顺序**反复出现有几个原因，其中一个原因是，它有助于保持**因果关系（causality）**。

那么因果顺序和线性一致性之间的关系是什么？答案是线性一致性**隐含着（implies）** 因果关系：任何线性一致的系统都能正确保持因果性【7】。

线性一致性确保因果性的事实使线性一致系统变得简单易懂，更有吸引力。然而，正如“[线性一致性的代价](http://ddia.vonng.com/#/ch9?id=线性一致性的代价)”中所讨论的，使系统线性一致可能会损害其性能和可用性，尤其是在系统具有严重的网络延迟的情况下（例如，如果系统在地理上散布）。出于这个原因，**一些分布式数据系统已经放弃了线性一致性**，从而获得更好的性能，但它们用起来也更为困难。

在**线性一致的数据存储中是不存在并发操作**的：必须有且仅有一条时间线，所有的操作都在这条时间线上，构成一个全序关系。可能有几个请求在等待处理，但是数据存储确保了每个请求都是在唯一时间线上的某个时间点自动处理的，**不存在任何并发**。

好消息是存在折衷的可能性。线性一致性并不是保持因果性的唯一途径 —— 还有其他方法。一个系统可以是因果一致的，而无需承担线性一致带来的性能折损（尤其对于CAP定理不适用的情况）。

在许多情况下，看上去需要线性一致性的系统，==实际上需要的只是因果一致性==，因果一致性可以更高效地实现。



实现因果一致的方法：

- 使用序列号，==兰伯特时间戳==，但是，为了实现诸如用户名上的唯一约束这种东西，仅有操作的全序是不够的，你还需要知道这个全序何时会尘埃落定。



如何确定全序关系已经尘埃落定，需要用==全序广播==

全序广播通常被描述为在节点间交换消息的协议。 非正式地讲，它要满足两个安全属性：

- **可靠交付（reliable delivery）**
  - 没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点。
- **全序交付（totally ordered delivery）**
  - 消息以相同的顺序传递给每个节点。

正确的全序广播算法必须始终保证可靠性和有序性，即使节点或网络出现故障。





## 分布式事务

### 两阶段提交

 2PC在某些数据库内部使用，也以**XA事务**的形式对应用可用【76,77】（例如Java Transaction API支持）或以SOAP Web服务的`WS-AtomicTransaction` 形式提供给应用。

两阶段提交（2PC）和两阶段锁定（请参阅“[两阶段锁定](http://ddia.vonng.com/#/ch7?id=两阶段锁定)”）是两个完全不同的东西。 2PC在分布式数据库中提供原子提交，而2PL提供可串行化的隔离等级。为了避免混淆，最好把它们看作完全独立的概念，并忽略名称中不幸的相似性。



 正常情况下，2PC事务以应用在多个数据库节点上读写数据开始。我们称这些数据库节点为**参与者（participants）**。当应用准备提交时，协调者开始阶段 1 ：它发送一个**准备（prepare）** 请求到每个节点，询问它们是否能够提交。然后协调者会跟踪参与者的响应：

- 如果所有参与者都回答“是”，表示它们已经准备好提交，那么协调者在阶段 2 发出**提交（commit）** 请求，然后提交真正发生。
- 如果任意一个参与者回复了“否”，则协调者在阶段2 中向所有节点发送**中止（abort）** 请求。

该协议包含两个关键的“不归路”点：当参与者投票“是”时，它承诺它稍后肯定能够提交（尽管协调者可能仍然选择放弃）；以及一旦协调者做出决定，这一决定是不可撤销的。这些承诺保证了2PC的原子性。 （单节点原子提交将这两个事件合为了一体：将提交记录写入事务日志。）

==如果此时协调者崩溃或网络出现故障==，参与者什么也做不了只能等待。参与者的这种事务状态称为**存疑（in doubt）** 的或**不确定（uncertain）** 的。

3PC也解决不了问题，所以2PC仍然被使用，尽管大家都清楚可能存在协调者故障的问题。



### 实践中的分布式事务

==分布式事务的名声毁誉参半==，尤其是那些通过两阶段提交实现的。许多云服务由于其导致的运维问题，而选择不实现分布式事务。分布式事务的某些实现会带来严重的性能损失 —— 例如据报告称，MySQL中的分布式事务比单节点事务慢10倍以上



但我们不应该直接忽视分布式事务，而应当更加仔细地审视这些事务，因为从中可以汲取重要的经验教训。首先，我们应该精确地说明“**分布式事务**”的含义。两种截然不同的分布式事务类型经常被混淆：

- **数据库内部的分布式事务**，在这种情况下，所有参与事务的节点都运行相同的数据库软件。
- **异构分布式事务**，在**异构（heterogeneous）** 事务中，参与者是由两种或两种以上的不同技术组成的

因此数据库内部的分布式事务通常工作地很好。另一方面，跨异构技术的事务则更有挑战性。



#### XA事务

X/Open XA( extended Architecture,XA)是异构环境下实施两阶段提交的一个工业标准。

XA并不是一个网络协议，而是一个与事务协调者进行通信的CAPI。当然，它也支持其他语言的API绑定，例如 Java EE中，XA事务是由Java事务API( Java TransactionAPI,JTA)来实现，JTA可以支持非常多JDBC( Java Databae Connectivity)驱动和消息队列驱动(通过Java消息服务，JMS)。

XA在协调者故障时，由于持有锁，会导致事务一直停在那里，可能需要手动回滚，或者采用启发式决策，即参与者单方面放弃事务，而不管协调者。



## 支持容错的共识

共识问题通常形式化描述如下：一个或多个节点可以提议某些值，由共识算法来决定最终值。对于预约座位的例子，当多个顾客同时试图购买最后一个座位时，处理顾客请求的每个节点可以提议它所服务的顾客ID,最后的决定则是关于由哪个顾客获得座位。

共识算法**必须满足以下性质**：

- 协商一致性，所有节点都接受相同的决议
- 诚实性，所有节点不能反悔，一项提议不能有两次决定
- 合法性，如果决定了值v，那么v一定是某个节点提议的
- 可终止性，节点如果不崩溃，最终一定可以达成决议
