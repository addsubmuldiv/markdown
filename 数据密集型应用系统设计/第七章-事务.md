# 第七章-事务

尤其会深入**并发控制**的领域，讨论各种可能发生的竞争条件，以及数据库如何实现**读已提交（read committed）**，**快照隔离（snapshot isolation）** 和**可串行化（serializability）** 等隔离级别。

随着这种新型分布式数据库的炒作，人们普遍认为事务是可伸缩性的对立面，任何大型系统都必须放弃事务以保持良好的性能和高可用性【5,6】。另一方面，数据库厂商有时将事务保证作为“重要应用”和“有价值数据”的基本要求。这两种观点都是**纯粹的夸张**。

非关系型数据库出现，为了提升性能舍弃了事务，或者重新定义了事务，提供一种弱的多的保证

## 事务相关概念

### ACID

ACID代表**原子性（Atomicity）**，**一致性（Consistency）**，**隔离性（Isolation）** 和**持久性（Durability）**。它由Theo Härder和Andreas Reuter于1983年提出，旨在为数据库中的容错机制建立精确的术语。不幸的是，==ACID现在几乎已经变成了一个营销术语。==

#### 原子性（可中止性）

ACID的原子性描述了当客户想进行多次写入，但因为一些故障事务没完成提交，那么就会中止回滚，撤销该事务迄今为止一切写入

ACID原子性的定义特征是：**能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。** 或许 **可中止性（abortability）** 是更好的术语，但本书将继续使用原子性，因为这是惯用词。

#### 一致性

在ACID的上下文中，**一致性**是指数据库在应用程序的特定概念中处于“良好状态”。ACID一致性的概念是，**对数据的一组特定约束必须始终成立**。即**不变量（invariants）**。

原子性，隔离性和持久性是数据库的属性，而一致性（在ACID意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母C不属于ACID。

乔·海勒斯坦（Joe Hellerstein）指出，在Härder与Reuter的论文中，“==ACID中的C”是被“扔进去凑缩写单词的==”【7】，而且那时候大家都不怎么在乎一致性。

#### 隔离性

ACID意义上的隔离性意味着，**同时执行的事务是相互隔离的**：它们不能相互冒犯。数据库确保当多个事务被提交时，结果与它们串行运行（一个接一个）是一样的，尽管实际上它们可能是并发运行的。传统的数据库教科书将隔离性形式化为**可串行化（Serializability）**

例如，如果一个事务进行多次写入，则另一个事务要么看到全部写入结果，要么什么都看不到，但不应该是一些子集。

#### 持久性

**持久性** 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。在带复制的数据库中，持久性可能意味着数据已成功复制到一些节点。为了提供持久性保证，数据库必须等到这些写入或复制完成后，才能报告事务成功提交。

**完美的持久性是不存在的** ：如果所有硬盘和所有备份同时被销毁，那显然没有任何数据库能救得了你。



### 单对象和多对象操作

#### 单对象写入

存储引擎一个几乎普遍的目标是：对单节点上的单个对象（例如键值对）上提供原子性和隔离性。

CAS以及其他单一对象操作被称为“轻量级事务”，甚至出于营销目的被称为“ACID”，但是这个术语是误导性的。事务通常被理解为，**将多个对象上的多个操作合并为一个执行单元的机制**。



#### 多对象事务

有一些场景中，单对象插入，更新和删除是足够的。但是许多其他场景需要协调写入几个不同的对象。这些应用仍然可以在没有事务的情况下实现。然而，**没有原子性，错误处理就要复杂得多，缺乏隔离性，就会导致并发问题**。



## 弱隔离级别

数据库一直试图通过提供**事务隔离（transaction isolation）** 来隐藏应用程序开发者的并发问题。实际上不幸的是：隔离并没有那么简单。**可串行的隔离**会有性能损失，许多数据库不愿意支付这个代价【8】。因此，系统通常使用较弱的隔离级别来防止一部分，而不是全部的并发问题。即使是很多流行的关系型数据库系统（通常被认为是“ACID”）也使用弱隔离级别，所以它们也不一定能防止这些错误的发生。

### 读已提交

1. 从数据库读时，只能看到已提交的数据（没有**脏读（dirty reads）**）。
2. 写入数据库时，只会覆盖已经写入的数据（没有**脏写（dirty writes）**）。

最常见的情况是，数据库通过使用**行锁（row-level lock）** 来防止脏写

大多数数据库防止脏读的方式：对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。



### 快照隔离和可重复读

读提交**无法避免**==不可重复读==

- **不可重复读（nonrepeatable read）** 或**读取偏差（read skew）**：如果在两个事务之间查询，可能出现出账减了，但是入账还没加上的情况，不过最终是==一致的==

![img](https://gitee.com/Lighters_c/picgo-bed/raw/master/fig7-6.png)

**快照隔离（snapshot isolation）**【28】是这个问题最常见的解决方案。想法是，每个事务都从数据库的**一致快照（consistent snapshot）** 中读取——也就是说，事务可以看到事务开始时在数据库中提交的所有数据。

快照隔离对长时间运行的只读查询（如备份和分析）非常有用。如果查询的数据在查询执行的同时发生变化，则很难理解查询的含义。

#### 快照隔离的实现

与读取提交的隔离类似，快照隔离的实现通常使用写锁来防止脏写（请参阅“[读已提交](http://ddia.vonng.com/#/ch7?id=读已提交)”），这意味着进行写入的事务会阻止另一个事务修改同一个对象。但是读取不需要任何锁定。从性能的角度来看，快照隔离的一个关键原则是：**读不阻塞写，写不阻塞读**。这允许数据库在处理一致性快照上的长时间查询时，可以正常地同时处理写入操作。且两者间没有任何锁定争用。

为了实现快照隔离，数据库使用了我们看到的用于防止脏读的机制的一般化。数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。因为它同时维护着单个对象的多个版本，所以这种技术被称为**多版本并发控制（MVCC, multi-version concurrency control）**。

如果一个数据库只需要提供**读已提交**的隔离级别，而不提供**快照隔离**，那么保留一个对象的两个版本就足够了：提交的版本和被覆盖但尚未提交的版本。支持快照隔离的存储引擎通常也使用MVCC来实现**读已提交**隔离级别。一种典型的方法是**读已提交**为每个查询使用单独的快照，而**快照隔离**对整个事务使用相同的快照。

==快照隔离是一个有用的隔离级别，特别对于只读事务而言。但是，许多数据库实现了它，却用不同的名字来称呼。结果，没有人真正知道**可重复读**的意思。==



### 防止丢失更新

- 原子写

  - 原子操作通常通过在读取对象时，获取其上的排它锁来实现。以便更新完成之前没有其他事务可以读取它。这种技术有时被称为**游标稳定性**

  - 下面的指令在大多数关系数据库中是并发安全的：

    ```sql
    UPDATE counters SET value = value + 1 WHERE key = 'foo';
    ```

  - MongoDB这样的文档数据库提供了对JSON文档的一部分进行本地修改的原子操作，Redis提供了修改数据结构（如优先级队列）的原子操作。

- 显示锁定

  - 防止丢失更新的另一个选择是让**应用程序**显式地锁定将要更新的对象。然后应用程序可以执行读取-修改-写入序列，如果任何其他事务尝试同时读取同一个对象，则强制等待，直到第一个**读取-修改-写入序列**完成。

- 自动检测更新丢失
  - 先让他们并发执行，但如果事务管理器检测到了更新丢失风险，则会中止当前事务，并强制回退到安全的“读-修改-写回”方式
- CAS
  - 在不提供事务的数据库中，有时会发现一种原子操作：**比较并设置（CAS, Compare And Set）**只有当前值从上次读取时一直未改变，才允许更新发生。如果当前值与先前读取的值不匹配，则更新不起作用，且必须重试读取-修改-写入序列。
  - 如果数据库允许`WHERE`子句从旧快照中读取，则此语句可能无法防止丢失更新

- 冲突解决和复制
  - 在多主或者无主数据库环境，基于锁或CAS操作的技术不适用于这种情况，这种复制数据库中的一种常见方法是允许并发写入创建多个冲突版本的值（也称为兄弟），并使用应用代码或特殊数据结构在事实发生之后解决和合并这些版本。

### 写入偏差与幻读

#### 写偏差

写入偏差可视为丢失更新问题的一般化，如果两个事务读取相同的记录集，然后更新记录集，不同的事务可能更新（插入、删除）不同的记录，则可能发生写入偏差，导致数据库状态不一致或者不符合约束条件。

#### 幻读

一个事务中的写入改变另一个事务的搜索查询的结果，被称为**幻读**

#### 解决方案

- for update 锁定一部分行，并告知数据库这些行用于更新；
  - 这种方式仅适用于查询时能返回一部分行并修改这些行的情况。如果是先查询，发现没有，然后再添加一行，使得查询先决条件改变，那我们就不能预先锁定不存在的行

- **物化冲突（materializing conflicts）**：幻读的问题是没有对象可以加锁，也许可以人为地在数据库中引入一个锁对象，它将幻读变为数据库中一组具体行上的锁冲突；不幸的是，弄清楚如何物化冲突可能很难，也很容易出错，如果没有其他办法可以实现，物化冲突应被视为最后的手段。

## 可串行化

**可串行化（Serializability）** 隔离通常被认为是最强的隔离级别。它保证即使事务可以并行执行，最终的结果也是一样的，就好像它们没有任何并发性，连续挨个执行一样。

三种实现可串行化的技术

### 真的串行

尽管这似乎是一个明显的主意，但数据库设计人员只是在2007年左右才决定，两个原因

- RAM足够便宜了
- 数据库设计人员意识到OLTP事务通常很短

#### 在存储过程中封装事务

具有单线程串行事务处理的系统不允许交互式的多语句事务。取而代之，应用程序必须提前将整个事务代码作为存储过程提交给数据库。

![img](https://gitee.com/Lighters_c/picgo-bed/raw/master/fig7-9.png)

为了提高串行的性能，可以采用分区，以便每个事务只需要在单个分区中读写数据，那么==每个分区就可以拥有自己独立运行的事务处理线程==。由于跨分区事务具有额外的协调开销，所以它们比单分区事务慢得多。



### 两阶段锁

大约30年来，在数据库中只有一种广泛使用的串行化算法：**两阶段锁定（2PL，two-phase locking）**

只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要**独占访问（exclusive access）** 权限

在2PL中，写入不仅会阻塞其他写入，也会阻塞读，反之亦然。快照隔离使得**读不阻塞写，写也不阻塞读**，是2PL和快照隔离之间的关键区别。

#### 实现两阶段锁

- 若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待。

- 事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是“==两阶段”这个名字的来源==：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁。



#### 谓词锁

谓词锁 对满足特定条件的对象进行锁定，可以用于新增数据的锁定；如果满足某种条件，就锁上。然后就和共享/排它锁一样



#### 索引范围锁

不幸的是谓词锁性能不佳：**如果活跃事务持有很多锁，检查匹配的锁会非常耗时。**因此，大多数使用2PL的数据库实际上实现了索引范围锁（也称为**间隙锁（next-key locking）**），这是一个简化的==近似版谓词锁==。

通过使谓词匹配到一个更大的集合来简化谓词锁是安全的。例如，如果你有在中午和下午1点之间预订123号房间的谓词锁，则锁定123号房间的所有时间段，或者锁定12:00~13:00时间段的所有房间（不只是123号房间）是一个安全的近似，因为任何满足原始谓词的写入也一定会满足这种更松散的近似。

这种方法能够有效防止幻读和写入偏差。索引范围锁并==不像谓词锁那样精确==（它们可能会锁定更大范围的对象，而不是维持可串行化所必需的范围），但是由于它们的开销较低，所以是一个==很好的折衷==。



### 可串行化快照隔离

一个称为**可串行化快照隔离（SSI, serializable snapshot isolation）** 的算法是非常有前途的。它提供了完整的可串行化隔离级别，但与快照隔离相比只有很小的性能损失。

今天，SSI既用于单节点数据库（PostgreSQL9.1 以后的可串行化隔离级别）和分布式数据库（FoundationDB使用类似的算法）。由于SSI与其他并发控制机制相比还很年轻，还处于在实践中证明自己表现的阶段。但它有可能因为足够快而在未来成为新的默认选项。



#### 悲观与乐观的并发控制

两阶段锁是一种所谓的**悲观并发控制机制（pessimistic）** ：它是基于这样的原则：如果有事情可能出错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情。

**串行化快照隔离**是一种**乐观（optimistic）** 的并发控制技术。在这种情况下，乐观意味着，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。提交的时候在看是不是有不好的事情发生，如果有，就中止



#### SSI原理

事务基于一个**前提（premise）** 采取行动（事务开始时候的事实，例如：“目前有两名医生正在值班”）。之后当事务要提交时，原始数据可能已经改变——前提可能不再成立。

先执行，直接到提交的时候检查两种会破坏前提的写入：

- 检测对旧MVCC对象版本的读取（读之前存在未提交的写入）
- 检测影响先前读取的写入（读之后发生写入）

如果前提被破坏了就中止。



#### 性能

与串行执行相比，可串行化快照隔离并不局限于单个CPU核的吞吐量：FoundationDB将检测到的串行化冲突分布在多台机器上，允许扩展到很高的吞吐量。即使数据可能跨多台机器进行分区，事务也可以在保证可串行化隔离等级的同时读写多个分区中的数据。